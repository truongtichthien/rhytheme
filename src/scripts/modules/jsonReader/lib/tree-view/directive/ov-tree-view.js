/**
 * $Id: $
 * (c) Copyright ALE USA Inc., 2015
 * All Rights Reserved. No part of this file may be reproduced, stored in a retrieval system,
 * or transmitted in any form or by any means, electronic, mechanical,
 * photocopying, or otherwise without the prior permission of ALE USA Inc..
 */

(function (ng) {
  'use strict';

  function TreeViewConstant() {}

  function OvTreeViewConverter(dottie) {
    var array;

    function _convert(json) {
      array = dottie.getArray(json, 'data.checkList');
      if (ng.isArray(array) && array.length > 0) {
        return array;
      } else {
        return [];
      }
    }

    return {
      convert: _convert
    };
  }

  function OvTreeViewCtrl(scope, dottie, $q, $timeout, $sce) {
    var vm = this,

      /** _rootArray stores all root nodes which are used to build all trees */
      _rootArray = [],

      /** _searchObj is container for properties which are used for searching, including 'method' & 'str' */
      _searchObj,


      searchMethod = {
        local: _localSearch,
        mixed: _mixedSearch,
        server: _serverSearch
      },

      DEFAULT_CONFIG = {
        ovTreeViewContainerTpl: '',
        nodeItemWrapperTpl: 'lib/tree-view/directive/template/nodeItemWrapper.html',
        nodeItemTpl: 'lib/tree-view/directive/template/defaultNodeItem.html',
        maxHeight: 60,
        showNodeLine: true,
        showCheckbox: false,
        isChecklist: false,
        enableDragDrop: false
      },

      /** DEFAULT_SEARCH_OBJ contains default value of properties which are used in _searchObj */
      DEFAULT_SEARCH_OBJ = {
        str: '',
        method: 'local'
      },

      /** while searching, the value of these attributes will be ignored in comparison to _searchObj.str
       * if there are any attributes need to be skipped in comparison in the future, please put them into this ignoredAttr array
       * ```
       ignoredAttr = ['_id', 'id', 'parent', 'menuItems', 'showChildren', 'level', 'isShowed', 'isWaiting',
       'addMenuItems', 'hasChildren', 'isLastChild', 'isFirstChild', 'lineArray', 'isSelected', 'callback', 'check',
       'highlightedTitle', 'searchMatched', 'childMatched'], */

      /** API_CALLER_RANGE defines the maximum number of APIs which can be called at the same time */
      API_CALLER_RANGE = 5,

      /** apiCallerArray stores all APIs which will be executed at the same time
       * please take a look at the jsdoc of _apiCaller function for more information */
      apiCallerArray = [],

      /** on server-search mode, use _.debounce function to avoid calling a function too many times
       * at present, this function is in the beginning, need to discuss more to implement completely */
      onChangeServerSearching = _.debounce(function () {
        if (_searchObj.str !== '') {
          console.log('I\'m on my way');
        }
      }, 500),

      linkingChar = _generateLinkingCharacter(),

      /** PADDING_TOP_BOTTOM defines the padding at top and bottom of #tree-view-container DOM element
       * this value is used in _scrollToPosition function, refer jsdoc of that function for more details */
      PADDING_TOP_BOTTOM,

      /** keyboard friendly */
      ENTER_KEY = 13, SPACE_KEY = 32, END_KEY = 35, HOME_KEY = 36, LEFT_ARROW_KEY = 37, UP_ARROW_KEY = 38, RIGHT_ARROW_KEY = 39, DOWN_ARROW_KEY = 40,

      CHECKED = 'checked', UNCHECKED = 'unchecked', INDETERMINATE = 'indeterminate';

    /**
     * @name _executeCallBack
     * @param node
     * @private
     * @description
     * Check if node has callback function or not and execute this function
     */
    function _executeCallBack(node) {
      if (ng.isFunction(node.callback)) {
        node.callback();
      }
    }

    /**
     * @name _selectNode
     * @param node
     * @param click
     * @private
     * @description
     * Used to
     */
    function _selectNode(node, click) {
      if (!vm.treeViewConfig.isChecklist || (vm.treeViewConfig.isChecklist && node.check !== CHECKED)) {
        if (!node.isSelected) {
          _.forEach(vm.treeViewArray, function (item, index) {
            item.isSelected = false;

            /** have to do node._id comparison to make sure that selecting exactly the node
             * in case of using leftArrow button, selected node can be jump over many nodes
             * if using $index (generated by ng-repeat), it can be 'undefined' value */
            if (item._id === node._id) {
              node.isSelected = true;
              vm.selectedNodeIndex = index;

              /** if node has callback function, execute the function */
              if (click) {
                _executeCallBack(node);
              }
            }
          });
        } else {
          /** if node has callback function, execute the function */
          if (click) {
            _executeCallBack(node);
          }
        }
      }
    }

    function _checkChildrenBox(node, status) {
      node.check = status;
      if (_countNodeChildren(node) > 0) {
        _.forEach(node.menuItems, function (child) {
          _checkChildrenBox(child, status);
        });
      }
    }

    function _lookupChildren(node) {
      var i, len, children = dottie.getArray(node, 'menuItems');
      for (i = 0, len = children.length; i < len - 1; i++) {
        if (children[i].check !== children[i + 1].check) {
          node.check = INDETERMINATE;
          return;
        }
      }
      /** script executes to this line means all children's status are 'checked' or 'unchecked'
       * so need to check the first child to know what status of them */
      node.check = children[0].check;
    }

    function _checkParentBox(node) {
      var tmpNode = node;
      while (tmpNode.parent) {
        _lookupChildren(tmpNode.parent);
        tmpNode = tmpNode.parent;
      }
    }

    function _checkNode(node, status) {
      node.check = status;

      if (node.menuItems.length > 0) {
        _checkChildrenBox(node, status);
      }

      if (node.parent) {
        _checkParentBox(node);
      }
    }

    function _toggleCheckNode(node) {
      if (!node.check || node.check === UNCHECKED || node.check === INDETERMINATE) {
        _checkNode(node, CHECKED);
      } else {
        _checkNode(node, UNCHECKED);
      }
    }

    function _scrollToPosition(node) {
      if (node) {
        var scrollTopMin, scrollTopMax,
          ngNode = ng.element(node).find('.ov-tree-view-container');

        PADDING_TOP_BOTTOM = vm.treeViewContainerPaddingTopBottom;

        scrollTopMin = ngNode.scrollTop();
        scrollTopMax = scrollTopMin + vm.treeViewContainerHeight - vm.itemWrapperHeight;
        vm.selectedPosition = vm.selectedNodeIndex * vm.itemWrapperHeight + PADDING_TOP_BOTTOM;

        /** in case END key is pressed */
        if (vm.selectedNodeIndex === vm.treeViewArray.length - 1) {
          ngNode.scrollTop(vm.selectedPosition + PADDING_TOP_BOTTOM);
        }

        /** in case selected node is out of view */
        else if (scrollTopMin - vm.selectedPosition > vm.itemWrapperHeight) {
          ngNode.scrollTop(vm.selectedPosition - PADDING_TOP_BOTTOM);
        }
        else if (vm.selectedPosition - scrollTopMax > vm.itemWrapperHeight) {
          ngNode.scrollTop(vm.selectedPosition + vm.itemWrapperHeight - (scrollTopMax - scrollTopMin) - PADDING_TOP_BOTTOM);
        }

        /** up or down node normally when pressing UP key or DOWN key */
        else {
          if (vm.selectedPosition < scrollTopMin) {
            ngNode.scrollTop(scrollTopMin - vm.itemWrapperHeight);
          }

          if (vm.selectedPosition > scrollTopMax) {
            ngNode.scrollTop(scrollTopMin + vm.itemWrapperHeight);
          }
        }
      }
    }

    function _keyEnterEvent(node) {
      _scrollToPosition(node);
      _.forEach(vm.treeViewArray, function (node) {
        if (dottie.getBoolean(node, 'isSelected')) {
          _selectNode(node, true);
        }
      });
    }

    function _keySpaceEvent(node) {
      _scrollToPosition(node);
      if (vm.treeViewConfig.showCheckbox || vm.treeViewConfig.isChecklist) {
        _.forEach(vm.treeViewArray, function (node) {
          if (dottie.getBoolean(node, 'isSelected')) {
            _toggleCheckNode(node);
          }
        });
      }
    }

    function _keyDownEvent(node) {
      var i, len;

      for (i = 0, len = vm.treeViewArray.length; i < len; i++) {
        if (dottie.getBoolean(vm.treeViewArray[i], 'isSelected')) {
          if (i + 1 < len) {
            vm.treeViewArray[i].isSelected = false;
            vm.treeViewArray[i + 1].isSelected = true;
            vm.selectedNodeIndex = i + 1;
          }
          break;
        }
      }

      /** if no selected node, select the first node */
      if (i === len) {
        if (vm.treeViewArray.length > 0) {
          vm.treeViewArray[0].isSelected = true;
          vm.selectedNodeIndex = 0;
        }
      }

      _scrollToPosition(node);
    }

    function _keyUpEvent(node) {
      var i, len;

      for (i = 0, len = vm.treeViewArray.length; i < len; i++) {
        if (dottie.getBoolean(vm.treeViewArray[i], 'isSelected')) {
          if (i - 1 >= 0) {
            vm.treeViewArray[i].isSelected = false;
            vm.treeViewArray[i - 1].isSelected = true;
            vm.selectedNodeIndex = i - 1;
          }

          break;
        }
      }

      /** if no selected node, select the last node */
      if (i === len) {
        if (vm.treeViewArray.length > 0) {
          vm.treeViewArray[len - 1].isSelected = true;
        }
      }

      /** execute the function to check and scroll to the selected node's position */
      _scrollToPosition(node);
    }

    function _keyLeftEvent() {
      var i, len;
      for (i = 0, len = vm.treeViewArray.length; i < len; i++) {
        if (dottie.getBoolean(vm.treeViewArray[i], 'isSelected')) {
          if (dottie.getBoolean(vm.treeViewArray[i], 'hasChildren') && dottie.getBoolean(vm.treeViewArray[i], 'showChildren')) {
            /** remove children if selected node has children and is expanding */
            _removeNodes(vm.treeViewArray, vm.treeViewArray[i]);
          } else {
            /** if selected node is collapsed, check if the parent is existed or not, then select the parent */
            if (dottie.getString(vm.treeViewArray[i], 'parent._id') !== '') {
              _selectNode(vm.treeViewArray[i].parent);
            }
          }
          break;
        }
      }
    }

    function _keyRightEvent() {
      var i, len;
      for (i = 0, len = vm.treeViewArray.length; i < len; i++) {
        if (dottie.getBoolean(vm.treeViewArray[i], 'isSelected')) {
          if (dottie.getBoolean(vm.treeViewArray[i], 'hasChildren')) {
            if (!dottie.getBoolean(vm.treeViewArray[i], 'showChildren')) {
              /** expand children if selected node has children and is collapsing */
              _pushNodes(vm.treeViewArray, vm.treeViewArray[i]);
            } else {
              /** if selected node is expanded, select the first child */
              _keyDownEvent();
            }
          }
          break;
        }
      }
    }

    function _keyHomeEvent(node) {
      _selectNode(vm.treeViewArray[0]);
      /** execute the function to check and scroll to the selected node's position */
      _scrollToPosition(node);
    }

    function _keyEndEvent(node) {
      var len = vm.treeViewArray.length;
      _selectNode(vm.treeViewArray[len - 1]);
      /** execute the function to check and scroll to the selected node's position */
      _scrollToPosition(node);
    }

    function _keyBinding(e) {
      var node = e.currentTarget;

      switch (e.keyCode) {
        case ENTER_KEY:
          _keyEnterEvent(node);
          break;
        case SPACE_KEY:
          _keySpaceEvent(node);
          break;
        case LEFT_ARROW_KEY:
          _keyLeftEvent();
          break;
        case UP_ARROW_KEY:
          _keyUpEvent(node);
          break;
        case RIGHT_ARROW_KEY:
          _keyRightEvent();
          break;
        case DOWN_ARROW_KEY:
          _keyDownEvent(node);
          break;
        case HOME_KEY:
          _keyHomeEvent(node);
          break;
        case END_KEY:
          _keyEndEvent(node);
          break;
      }
    }

    function _countNodeChildren(node) {
      return dottie.getNumber(node, 'menuItems.length');
    }

    function _generateLinkingCharacter() {
      return '_' + (_.random(10, true).toString().substr(2)) + '_';
    }

    /** */
    function _nodeCreator(obj, isShowed) {
      _.forEach(obj.menuItems, function (node) {
        _nodeDecorator(node, obj, isShowed);
        if (_countNodeChildren(node) > 0) {
          _nodeCreator(node, isShowed);
        }
      });
    }

    function _nodeDecorator(child, parent/*, isShowed*/) {
      if (ng.isObject(child)) {
        if (!child._id) {
          child._id = parent ? parent._id + linkingChar + child.id : child.id;
        }
        child.level = parent ? parent.level + 1 : 0;
        child.showChildren = child.showChildren || false;
        child.isWaiting = false;
        child.isShowed = child.isShowed || false;
        child.parent = parent;
        child.isSelected = child.isSelected || false;
        child.callback = child.callback || ng.noop;
        child.check = child.check || UNCHECKED;
        child.lineArray = [];
        child.isFirstChild = false;
        child.isLastChild = false;
        child.searchMatched = child.searchMatched || false;
        child.childMatched = child.childMatched || false;
        child.highlightedTitle = child.highlightedTitle || false;

        /** need to investigate to handle node decorating in case of rebuild */
        //child.menuItems = dottie.getNumber(child, 'menuItems.length') === 0 && ng.isFunction(child.addMenuItems) ? [] : child.menuItems;
        child.menuItems = ng.isFunction(child.addMenuItems) ? [] : child.menuItems;
        child.hasChildren = ng.isFunction(child.addMenuItems) || _countNodeChildren(child) > 0;
      }
    }

    /**
     * @name _findNodeIndex
     * @param viewArray
     * @param node
     * @returns {number}
     * @private
     * @description
     * Find the node's location in viewArray
     * The number which is returned will be the location to add this node into viewArray
     */
    function _findNodeIndex(viewArray, node) {
      return _.findIndex(viewArray, function (item) {
        return item._id === node._id;
      });
    }

    /**
     * @name _locateNode
     * @param viewArray
     * @param node
     * @param position
     * @private
     * @description
     * Put a node to exactly position
     */
    function _locateNode(viewArray, node, position) {
      node.isShowed = true;
      viewArray.splice(position, 0, node);
    }

    /**
     * @name _createPromises
     * @param itemArray
     * @param range
     * @param point
     * @returns {{promises: Array, pointer: *}}
     * @private
     * @description
     * Return a promise array
     */
    function _createPromises(itemArray, range, point) {
      var result = {
        promises: [],
        pointer: point
      }, i = 0;

      if (ng.isArray(itemArray)) {
        for (i; i < range; i++) {
          if (ng.isDefined(itemArray[point + i])) {
            if (ng.isFunction(itemArray[point + i].addMenuItems)) {
              result.promises.push(itemArray[point + i].addMenuItems());
            }
          }
        }
        result.pointer = point + i;
      }

      return result;
    }

    function _apiCaller(itemArray, range, pointer, searchMode, fnCallback) {
      var promises = {},
        position = pointer || 0;

      promises = _createPromises(itemArray, range, position);

      $q.all(promises.promises)
        .then(function (data) {
          _.forEach(data, function (array) {
            var i = 0,
              len = itemArray.length;

            for (i; i < len; i++) {
              if (_countNodeChildren(itemArray[i]) === 0) {
                itemArray[i].menuItems = array;
                itemArray[i].isWaiting = false;

                /** check if response array is empty or not */
                if (array.length > 0) {
                  itemArray[i].hasChildren = true;
                  if (searchMode) {
                    _nodeCreator(itemArray[i]);
                  } else {
                    _pushNodes(vm.treeViewArray, itemArray[i]);
                  }
                } else {
                  /** if response array is empty, mark this node doesn't have any children */
                  itemArray[i].hasChildren = false;
                }
                break;
              }
            }
          });
        })
        .finally(function () {
          if (position + range < itemArray.length) {
            _apiCaller(itemArray, range, promises.pointer, searchMode, fnCallback);
          } else {
            apiCallerArray = [];

            if (ng.isFunction(fnCallback)) {
              fnCallback();
            }
          }
        });
    }

    /** */
    function _pushNodes(viewArray, node) {
      if (ng.isFunction(node.addMenuItems) && _countNodeChildren(node) === 0) {
        node.isWaiting = true;
        _checkNode(node, UNCHECKED);
        _apiCaller([node], 1, 0, false);
      }

      else if (_countNodeChildren(node) > 0 && node.isShowed) {
        var position = _findNodeIndex(viewArray, node) + 1;

        _nodeCreator(node);

        _.forEach(node.menuItems, function (child, i) {
            if (_searchObj.str !== '') {
              if (node.rootObj) {
                if (child.searchMatched || child.childMatched) {
                  _locateNode(viewArray, child, position + i);
                }
              } else {
                if (node.searchMatched) {
                  _locateNode(viewArray, child, position + i);
                } else {
                  if (node.childMatched) {
                    _locateNode(viewArray, child, position + i);
                  }
                }
              }
            } else {
              _locateNode(viewArray, child, position + i);
            }

            _markLastChild(node);
            _drawNodeLine(child);
            node.showChildren = true;
          }
        );
      }
    }

    /**
     * @name _removeNodes
     * @param view
     * @param node
     * @private
     * @description
     * Call _emptyArray function to remove all node's children out of view
     */
    function _removeNodes(view, node) {
      node.showChildren = false;
      _emptyArray(view, node);
    }

    /**
     * @name _emptyArray
     * @param view
     * @param node
     * @private
     */
    function _emptyArray(view, node) {
      if (_countNodeChildren(node) > 0 && node.isShowed) {
        _.remove(view, function (item) {
          /** compare the item._id with the node._id to avoid removing the selected node
           * only remove items with _id starting by node._id */
          if (item._id !== node._id) {
            /** remove all nodes which have '_id' starting with their parent's '_id' */
            if (item._id.indexOf(node._id + linkingChar) === 0) {
              /** compare id of parent to know which node should be removed */
              item.isShowed = false;
              item.isSelected = false;
              item.showChildren = false;
              return true;
            }
          }
          return false;
        });

        /**
         * Note: Below code lines are optional, their necessary depends on user's behavior.
         * When collapsing a parent node which contains a API caller, all children nodes should be removed,
         * after that, parent node can get new data as children when user expands it again
         */
        if (ng.isFunction(node.addMenuItems) && _countNodeChildren(node) > 0) {
          node.menuItems.length = 0;
        }
      }
    }

    function _markLastChild(node) {
      if (vm.treeViewConfig.showNodeLine) {
        var i = 0,
          len = _countNodeChildren(node),
          flag = 0, setFirstNode = false;
        if (len > 0) {
          for (i; i < len; i++) {
            node.menuItems[i].isLastChild = false;
            node.menuItems[i].isFirstChild = false;

            if (node.menuItems[i].isShowed) {
              if (!setFirstNode) {
                node.menuItems[i].isFirstChild = true;
                setFirstNode = true;
              }
              flag = i;
            }
          }
          node.menuItems[flag].isLastChild = true;
        }
      }
    }

    function _drawNodeLine(node) {
      var array = ng.isDefined(node) ? [node] : vm.treeViewArray,
        i = 0,
        len = array.length,
        l, parentLineArray;

      for (i; i < len; i++) {
        if (array[i].isShowed) {
          if (dottie.getNumber(array[i], 'lineArray.length') > 0) {
            array[i].lineArray = [];
          }

          if (vm.treeViewConfig.showNodeLine) {
            parentLineArray = dottie.getArray(array[i], 'parent.lineArray');
            l = parentLineArray.length - 1;

            for (l; l >= 0; l--) {
              array[i].lineArray.unshift({
                leftBorder: parentLineArray[l].leftBorder,
                extraBorder: !dottie.getBoolean(array[i], 'children.isFirstChild')
              });
            }

            if (dottie.getBoolean(array[i], 'parent.isLastChild')) {
              if (dottie.getNumber(array[i], 'lineArray.length') > 0) {
                array[i].lineArray[0].leftBorder = false;
              }
            }

            if (dottie.getString(array[i], 'parent._id') !== '') {
              array[i].lineArray.unshift({
                leftBorder: true,
                bottomBorder: true,
                extraBorder: !dottie.getBoolean(array[i], 'isFirstChild')
              });
            }
          }
        }
      }
    }

    function _findMatchedString(string, subStr, caseSensitive) {
      var regex = new RegExp(subStr, caseSensitive ? 'g' : 'gi');
      return ng.isArray(string.match(regex));
    }

    function _highlightMatchedString(string, subStr, caseSensitive) {
      var regex = new RegExp(subStr, caseSensitive ? 'g' : 'gi');
      return $sce.trustAsHtml(
        string
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(regex, '<span class="highlighted">$&</span>')
      );
    }

// function _findDeeper(obj, tmpResult, str) {
//   if (ng.isObject(obj)) {
//     var lastIndex;
//
//     obj.isShowed = true;
//     tmpResult.push(obj);
//
//     if (_countNodeChildren(obj) > 0) {
//       obj.showChildren = true;
//       obj.hasChildren = true;
//
//       _.forEach(obj.menuItems, function (item) {
//         item.level = obj.level + 1;
//         _findDeeper(item, tmpResult, str);
//       });
//     }
//
//     /** check if the grant child is matched, if not, check the child (its parent) */
//     lastIndex = tmpResult.length - 1;
//
//     if (dottie.getString(tmpResult[lastIndex], '_id') === dottie.getString(obj, '_id')) {
//       for (var key in obj) {
//         if (obj.hasOwnProperty(key) && (ignoredAttr.indexOf(key) < 0)) {
//           if (obj[key].toLowerCase().indexOf(str.toLowerCase()) < 0) {
//             obj.isShowed = false;
//             obj.isSelected = false;
//             obj.searchMatched = false;
//             tmpResult.pop();
//           } else {
//             obj.hasChildren = false;
//             obj.searchMatched = true;
//             obj.highlightedTitle = _highlightMatchedString(obj.title, str);
//           }
//         }
//       }
//     }
//
//     _markLastChild(obj);
//   }
// }

    function _findDeeperAndShowWholeNode(obj, tmpResult, str) {
      if (ng.isObject(obj)) {
        // console.log(obj.title);
        tmpResult.push(obj);
        obj.isShowed = true;

        if (_countNodeChildren(obj) > 0) {
          obj.hasChildren = true;
          obj.showChildren = false;
          obj.childMatched = false;
          _.forEach(obj.menuItems, function (item) {
            _findDeeperAndShowWholeNode(item, tmpResult, str);
          });
        }

        if (obj.title) {
          /** compare search string */
          var stringFound = _findMatchedString(obj.title, str, false);

          obj.searchMatched = stringFound;
          if (stringFound) {
            obj.highlightedTitle = _highlightMatchedString(obj.title, str, false);
          } else {
            obj.highlightedTitle = null;
          }

          /** if the current node has a matched string,
           * then mark a flag to show child nodes on the parent */
          if (stringFound || obj.showChildren) {
            if (dottie.getString(obj.parent, '_id') !== '') {
              obj.parent.isShowed = true;
              obj.parent.showChildren = true;
              obj.parent.childMatched = true;
            }
          }

          if (stringFound && !obj.showChildren) {
            _removeNodes(tmpResult, obj);
          }

          /** not matched */
          if (!stringFound) {
            /** has children but no child matched */
            // if (obj.hasChildren && !obj.showChildren && !obj.parent.showChildren) {
            if (obj.hasChildren && !obj.showChildren) {
              /** the code line below is an alternative way to show the tree after searching
               * unblock the code line to know how it works
               * ```
               * if (obj.hasChildren && !obj.showChildren && !obj.parent.showChildren) { */
              obj.isShowed = false;
              /** get the node out of the stack if there is no child matched the string */
              _.remove(tmpResult, function (item) {
                /** remove all children nodes */
                if (item._id.indexOf(obj._id) === 0) {
                  /** compare id of parent to know which node should be removed */
                  item.isShowed = false;
                  item.isSelected = false;
                  return true;
                }
                return false;
              });
            }
          }
        }

        _markLastChild(obj);
      }
    }

    function _showResult(result) {
      if (result.length > 0) {
        _.forEach(result, function (item) {
          vm.treeViewArray.push(item);
        });
      }
    }

    function _localSearch() {
      var tmpResult;

      _.forEach(_rootArray, function (rootObj) {
        tmpResult = [];
        // _findDeeper(rootObj, tmpResult, _searchObj.str);
        _findDeeperAndShowWholeNode(rootObj, tmpResult, _searchObj.str);
        // _findDeeperAndShowEntireNodeV2(vm.treeViewArray, tmpResult, _searchObj.str);
        _showResult(tmpResult);
      });

      _drawNodeLine();
    }

    function _pickAddMenuFunction(node) {
      if (ng.isFunction(node.addMenuItems) && _countNodeChildren(node) === 0) {
        apiCallerArray.push(node);
      } else {
        if (_countNodeChildren(node) > 0) {
          _.forEach(node.menuItems, function (item) {
            _pickAddMenuFunction(item);
          });
        }
      }
    }

    function _mixedSearch() {
      var i, len;

      if (!vm.spinner) {
        vm.spinner = true;
      }

      for (i = 0, len = _rootArray.length; i < len; i++) {
        _pickAddMenuFunction(_rootArray[i]);
      }

      if (dottie.getNumber(apiCallerArray, 'length') > 0) {
        _apiCaller(apiCallerArray, API_CALLER_RANGE, 0, true, _searchEntireTree);
      } else {
        vm.spinner = false;
        _localSearch();
      }
    }

    function _serverSearch() {
      onChangeServerSearching();
    }

    function _searchEntireTree() {
      vm.treeViewArray = [];
      if (_searchObj.str !== '') {
        searchMethod[_searchObj.method]();
      } else {
        _rebuildTree();
      }
    }

    function _pushAllNodes(array, node) {
      if (ng.isFunction(node.addMenuItems) && _countNodeChildren(node) === 0) {
        node.isWaiting = true;
        apiCallerArray.push(node);
      } else {
        if (!node.showChildren) {
          _pushNodes(array, node);
        }

        if (_countNodeChildren(node) > 0) {
          _.forEach(node.menuItems, function (item) {
            _pushAllNodes(array, item);
          });
        }
      }
    }

    function _expandAll() {
      _.forEach(_rootArray, function (node) {
        // if (_searchObj.str !== '') {
        //   _searchEntireTree();
        // } else {
        _pushAllNodes(vm.treeViewArray, node);
        // }
      });

      if (dottie.getNumber(apiCallerArray, 'length') > 0) {
        _apiCaller(apiCallerArray, API_CALLER_RANGE, 0, false, _drawNodeLine);
      }
    }

    function _expandAllTree(fnCallback) {
      if (ng.isFunction(fnCallback)) {
        vm.spinner = true;
        fnCallback()
          .then(function (data) {

            // fake process
            //var newObject = ng.copy(object);
            //newObject.id = _createRandomName();
            //newObject.name = _createRandomName();
            //newObject.menuItems = data;
            // end of fake process

            vm.treeViewArray = [];
            _rootArray = [];
            //_rootArray.push(newObject);
            console.info(data);
            _buildTree(_rootArray);
          }, function (error) {
            /** need implement an ovAlert here */
            console.error(error);
          })
          .finally(function () {
            _expandAll();
            vm.spinner = false;
          });
      } else if (dottie.getNumber(vm.treeViewArray, 'length') > 0) {
        _expandAll();
      }
    }

    function _collapseAllTree() {
      if (dottie.getNumber(vm.treeViewArray, 'length') > 0) {
        _.forEach(_rootArray, function (root) {
          if (root.isShowed) {
            _removeNodes(vm.treeViewArray, root);
          }
        });
      }
    }

    function _buildTree(data) {
      _.forEach(data, function (root) {
        if (dottie.getString(root, 'id') !== '') {
          _nodeDecorator(root, null);
          if (_countNodeChildren(root) > 0) {
            _nodeCreator(root);
          }
        }
      });
    }

    function _rebuildTree() {
      vm.treeViewArray.length = 0;
      apiCallerArray = [];
      _rootArray = [];

      _getInitialData(scope.treeViewObject);
      _buildTree(_rootArray);
      _showTree(vm.treeViewArray, _rootArray);

      if (_searchObj.str !== '') {
        _searchEntireTree();
      }
    }

    function _checkToShowNode(viewArray, node) {
      if (dottie.getBoolean(node, 'showChildren')) {
        _pushNodes(viewArray, node);

        var i, len = _countNodeChildren(node);

        if (len > 0) {
          for (i = 0; i < len; i++) {
            _checkToShowNode(viewArray, node.menuItems[i]);
          }
        }
      }
    }

    function _showTree(view, data) {
      _.forEach(data, function (root) {
        root.isShowed = true;
        view.push(root);
        _checkToShowNode(view, root);
      });

      // var i, len, child;
      // for (i = 0, len = dottie.getNumber(data, 'length'); i < len; i++) {
      //   child = data[i];
      //   if (dottie.getString(data[i], '_id') !== '') {
      //     _nodeDecorator(data[i], null);
      //     view.push(data[i]);
      //     _checkToShowNode(view, data[i]);
      //   }
      // }
    }

    function _getInitialData(treeViewObj) {
      if (ng.isObject(treeViewObj)) {
        var array, config, controlFunction, searchObject, lastScrollTop;

        array = ng.copy(treeViewObj.seedArray);
        config = treeViewObj.config;
        controlFunction = treeViewObj.controlFunction;
        searchObject = treeViewObj.searchObject;
        lastScrollTop = treeViewObj.lastScrollTop;

        if (!ng.isArray(array)) {
          console.error('OvTreeView need an array as a input data.');
        }
        else if (ng.isArray(array) && array.length > 0) {
          _.forEach(array, function (item) {
            _rootArray.push(item);
          });
        }

        if (ng.isObject(config)) {
          vm.treeViewConfig = ng.extend(DEFAULT_CONFIG, config);
          if (vm.treeViewConfig.isChecklist) {
            vm.treeViewConfig.showCheckbox = true;
          }
        }

        if (ng.isObject(controlFunction)) {
          vm.treeViewFunction = treeViewObj.controlFunction;
          treeViewObj.controlFunction.expandAll = _expandAllTree;
          treeViewObj.controlFunction.collapseAll = _collapseAllTree;
          treeViewObj.controlFunction.rebuildTree = _rebuildTree;
          /** treeViewObj.controlFunction.searchNode = _.debounce(function () {
            _searchEntireTree();
            scope.$apply();
          }, 1000); */
          treeViewObj.controlFunction.searchNode = function () {
            var clearTimeout = $timeout(function () {
              _searchEntireTree();
              $timeout.cancel(clearTimeout);
            }, 500);
          };
        }

        if (ng.isObject(searchObject)) {
          _searchObj = treeViewObj.searchObject;
          _searchObj.str = _searchObj.str || DEFAULT_SEARCH_OBJ.str;
          _searchObj.method = _searchObj.method || DEFAULT_SEARCH_OBJ.method;
        }

        if (ng.isObject(lastScrollTop)) {
          vm.lastScrollTop = treeViewObj.lastScrollTop;
          vm.lastScrollTop.index = vm.lastScrollTop.index || 0;
        }

        // if (_searchObj.str !== '') {
        //   _expandAll();
        // }

        if (vm.treeViewConfig.enableDragDrop) {
          vm.treeViewConfig.ovTreeViewContainerTpl = 'lib/tree-view/directive/template/treeViewContainerWithDragDrop.html';
        } else {
          vm.treeViewConfig.ovTreeViewContainerTpl = 'lib/tree-view/directive/template/treeViewContainer.html';
        }
      }
    }

    /** =====////=====////=====////=====////=====////=====////=====////=====////=====////=====////===== */

    vm.treeViewArray = [];
    vm.selectedNodeIndex = 0;

    _getInitialData(scope.treeViewObject);

    if (ng.isArray(_rootArray) && _rootArray.length > 0) {
      if (ng.isUndefined(_rootArray[0]._id)) {
        _buildTree(_rootArray);
      }
      _showTree(vm.treeViewArray, _rootArray);
    }

    vm.toggleExpansion = function (node) {
      if (!node.showChildren) {
        _pushNodes(vm.treeViewArray, node);
      } else {
        _removeNodes(vm.treeViewArray, node);
      }
    };
    vm.toggleCheckNode = function (node, e) {
      _toggleCheckNode(node);
      e.stopPropagation();
    };

    vm.selectNode = _selectNode;
    vm.keyBinding = _keyBinding;
    vm.scrollToPosition = _scrollToPosition;

    /**/
    vm.drawNodeLine = _drawNodeLine;
    vm.nodeDecorator = _nodeDecorator;
    vm.markLastChild = _markLastChild;

    scope.$on('$destroy', function () {
      console.log('scope destroyed');
      vm.treeViewArray.length = 0;
    });
  }

  function treeViewLink($window, $timeout, dottie, scope, ele) {
    var vm,
      clientWidth = 'clientWidth',
      scrollWidth = 'scrollWidth',

      offsetHeight = 'offsetHeight',
      clientHeight = 'clientHeight',

      stopFindContainer,
      stopFindNode,

      // oldLocation, newLocation,
      // draggedNode, nodeAbove,
      htmlFontSize = parseInt(ng.element('html').css('font-size'));

    vm = dottie.getObject(scope, 'vm');

    function _collectNodeItems(clientW) {
      var nodeItemArray, nodeArray, sortedArray;

      nodeItemArray = ele.find('.node-item-wrapper');

      vm.longestNode = {};

      nodeArray = _.map(nodeItemArray, function (node) {
        return {
          id: dottie.getString(ng.element(node).scope(), 'item._id'),
          width: node[scrollWidth],
          content: node
        };
      });

      sortedArray = _.sortBy(nodeArray, function (node) {
        return node.width;
      });

      vm.longestNode = sortedArray[sortedArray.length - 1];

      if (vm.longestNode) {
        if (vm.longestNode.width <= clientW) {
          vm.treeViewContainerScrollWidth = 'auto';
        } else {
          vm.treeViewContainerScrollWidth = vm.longestNode.width;
          vm.longestNode.content.addEventListener('DOMNodeRemoved', function () {
            vm.treeViewContainerScrollWidth = 'auto';
          });
        }
      }
    }

    function _updateTreeViewContainerWidth(e) {
      if (ng.isObject(e)) {
        var node = e.currentTarget || e[0];

        _collectNodeItems(node[clientWidth]);

        /** if container suddenly displays horizontal scroll bar, get new height */
        if (node[offsetHeight] >= node[clientHeight]) {
          vm.treeViewContainerHeight = vm.treeViewContainerHeight !== node[clientHeight] ? node[clientHeight] : vm.treeViewContainerHeight;
        } else {
          vm.treeViewContainerHeight = vm.treeViewConfig.maxHeight * htmlFontSize;
        }

        /** update the position of the vertical scroll */
        if (ng.isObject(vm.lastScrollTop)) {
          vm.lastScrollTop.index = vm.treeViewContainer.scrollTop();
        }

        scope.$apply();
      }
    }

    /** get the height of container when tree view overflows */
    //stopFindContainer = scope.$watch(function () {
    //  return (vm.treeViewContainer[0][scrollHeight] > htmlFontSize * vm.treeViewConfig.maxHeight);
    //}, function (newVal) {
    //  if (newVal) {
    //    vm.treeViewContainerHeight = htmlFontSize * vm.treeViewConfig.maxHeight;
    //    stopFindContainer();
    //  }
    //});

    function _findTreeViewNodeWrapper() {
      stopFindNode = scope.$watch(function () {
        vm.itemWrapper = ele.find('.node-item-wrapper');
        return vm.itemWrapper.length;
      }, function (newVal) {
        if (newVal > 0) {
          vm.itemWrapperHeight = vm.itemWrapper[0][offsetHeight];
          stopFindNode();
        }
      });
    }

    function _findTreeViewContainer() {
      stopFindContainer = scope.$watch(function () {
        vm.treeViewContainer = ele.find('.ov-tree-view-container');
        return vm.treeViewContainer.length;
      }, function (newVal) {
        /** if '.ov-tree-view-container' has rendered on DOM already, newVal should be 1 */
        if (newVal > 0) {
          vm.treeViewContainerHeight = vm.treeViewConfig.maxHeight * htmlFontSize;
          vm.treeViewContainerPaddingTopBottom = parseInt(vm.treeViewContainer.css('padding-top'));

          _findTreeViewNodeWrapper();
          _collectNodeItems();

          /** calculate the container's width when resizing window */
          ng.element($window).bind('resize', function () {
            // _.debounce(function () {
            _updateTreeViewContainerWidth(vm.treeViewContainer);
            // }, 100);
          });

          /** calculate the width when scrolling the container */
          vm.treeViewContainer.bind('scroll', function (e) {
            _updateTreeViewContainerWidth(e);
          });

          $timeout(function () {
            if (dottie.getNumber(vm.lastScrollTop, 'index') >= 0) {
              /** scroll to the last position which has been before */
              vm.treeViewContainer.scrollTop(vm.lastScrollTop.index);
            }
          });

          stopFindContainer();
        }
      });
    }

    _findTreeViewContainer();

    // function _findNodeIndex(viewArray, node) {
    //   var i = 0,
    //     len = viewArray.length;
    //
    //   for (i; i < len; i++) {
    //     if (viewArray[i]._id === node._id) {
    //       return i;
    //     }
    //   }
    // }
    // scope.$on('tree-view-container.over', function (e, el) {
    //   el.addClass('over');
    //   draggedNode = el.scope().item;
    //   oldLocation = _findNodeIndex(vm.treeViewArray, el.scope().item);
    // });
    // scope.$on('tree-view-container.out', function (e, el) {
    //   el.removeClass('over');
    //   $timeout(function () {
    //     newLocation = _findNodeIndex(vm.treeViewArray, el.scope().item);
    //
    //     if (ng.isDefined(oldLocation) && ng.isDefined(newLocation) && oldLocation !== newLocation) {
    //       console.log('chay vo day ne');
    //       nodeAbove = vm.treeViewArray[newLocation - 1];
    //       if (nodeAbove.hasChildren) {
    //         if (nodeAbove.showChildren) {
    //           nodeAbove.menuItems.push(el.scope().item);
    //           vm.nodeDecorator(el.scope().item, nodeAbove, nodeAbove.menuItems[0].isShowed);
    //           vm.markLastChild(nodeAbove);
    //         } else {
    //
    //         }
    //       } else {
    //
    //       }
    //       vm.drawNodeLine();
    //     }
    //   });
    // });

    /** get the element which has class 'ov-tree-view-container'
     * and set its height is equal to the value of 'maxHeight' in treeViewConfig */
  }

  function OvTreeView($window, $timeout, dottie) {
    return {
      restrict: 'EA',
      scope: {
        treeViewObject: '='
      },
      templateUrl: 'lib/tree-view/directive/template/treeViewTemplate.html',
      link: function (scope, ele) {
        treeViewLink($window, $timeout, dottie, scope, ele);
      },
      controller: OvTreeViewCtrl,
      controllerAs: 'vm'
    };
  }

  function OvTreeViewFunctionalButton() {
    return {
      restrict: 'EA',
      scope: {
        treeViewObject: '=',
        functionalButtonConfig: '='
      },
      templateUrl: 'lib/tree-view/directive/template/treeViewFunctionalButtonTemplate.html',
      link: function (scope) {
        var method,
          TITLE = {
            expandAll: 'Expand all',
            collapseAll: 'Collapse all',
            rebuildTree: 'Rebuild tree'
          };

        scope.btn = {};

        if (ng.isObject(scope.functionalButtonConfig)) {
          if (ng.isDefined(scope.functionalButtonConfig.method)) {
            method = scope.functionalButtonConfig.method;
          } else {
            console.error('Functional method is undefined.');
          }
        }

        scope.btn.functionalMethod = function () {
          if (ng.isObject(scope.treeViewObject)) {
            if (ng.isObject(scope.treeViewObject.controlFunction)) {
              var func = scope.treeViewObject.controlFunction[method];
              if (ng.isFunction(func)) {
                func();
              } else {
                console.error('The function ', func, ' is not existed.');
              }
            }
          }
        };

        scope.btn.title = TITLE[method];
        scope.btn.btnClass = scope.treeViewObject.btnClass;
        scope.btn.disabled = scope.treeViewObject.disabled;
      }
    };
  }

  function OVCheckbox() {
    return {
      restrict: 'EA',
      scope: {
        item: '=',
        func: '&',
        stopPropagation: '=?'
      },
      controller: ['$scope', function (scope) {
        scope.onClickFunc = function () {
          scope.func();
        };
      }],
      template: '<input class="ov-checkbox-input" type="checkbox">' +
      '<span class="ov-checkbox-display" ng-click="func({item: item, event: $event})"></span>',
      link: function (scope, ele) {
        var CHECKED = 'checked', UNCHECKED = 'unchecked', INDETERMINATE = 'indeterminate';

        scope.$watch('item.check', function (newVal) {
          var inputEle = ele.children();
          switch (newVal) {
            case INDETERMINATE:
              inputEle.prop(CHECKED, false);
              inputEle.prop(INDETERMINATE, true);
              break;
            case CHECKED:
              inputEle.prop(CHECKED, true);
              inputEle.prop(INDETERMINATE, false);
              break;
            case UNCHECKED:
              inputEle.prop(CHECKED, false);
              inputEle.prop(INDETERMINATE, false);
              break;
          }
        });
      }
    };
  }

  OvTreeViewConverter.$inject = ['dottie'];
  OvTreeViewCtrl.$inject = ['$scope', 'dottie', '$q', '$timeout', '$sce'];
  OvTreeView.$inject = ['$window', '$timeout', 'dottie'];

  ng.module('treeView', ['ngSanitize', 'dottie'])
    .constant('ovTreeViewConstant', TreeViewConstant)
    .service('ovTreeViewConverter', OvTreeViewConverter)
    .directive('ovTreeView', OvTreeView)
    .directive('ovTreeViewFunctionalButton', OvTreeViewFunctionalButton)
    .directive('ovCheckbox', OVCheckbox);

})(angular);
